\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{fancyhdr}

\pagestyle{fancy}
\lhead{TDDC78 Lab 1}
\rhead{Hallberg, Svensk}

\begin{document}

\title{TDDC78 Lab 1\\
        Image filter - MPI}
\author{Christopher Hallberg \\
        Gustav Svensk}
\maketitle

\thispagestyle{empty}

\newpage
\setcounter{page}{1}
\tableofcontents
\newpage

\section{Averaging Filter}
In the averaging filter each pixel gets its value according to a weighted average
of neighbouring pixels in the shape of a rectangle with a user specified radius. 
Our implementation uses the given Gaussian distribution.

\subsection{Description}
This section provides a high level overview of the parallel program. 
The code is of the same structure as the one provided on the course homepage,
but with added functionality for MPI. When the
program is started the root processor reads the input file and calls
the function calculating the Gaussian coefficients. The root processor then
broadcasts the Gaussian coefficients, radius of the rectangle and size of the image.


In order to utilize the cache functionality as much as possible we split the image
horizontally in equally sized parts. If the y-size of the image is not divisible
by the number of processors used the last processor will be assigned the
additional lines. Each processor will allocate local memory for their part of the
image plus extra shadow pixels needed to filter along the y-axis. The memory
needed for these shadow pixels will correspond to two times the width of the
image times the radius of the filtering rectangle. The root processor then 
scatters the image to every processor.  

The filter function provided have been split into two separate functions, the
first filtering along the x-axis and the other filtering along the y-axis. Some
small changes had to be made to copy memory and handle the shadow pixels. The
y-filter have two additional arguments specifying if the process will need
information about shadow pixels from another process or not. 

If there is only one process it will just call the two filter functions. If
there are more than one process the root process first sends the part of the
image left over after the integer division to the last process. All processes
filter along the x-axis which require no message passing between them.
The required shadow pixels are then passed, starting by first sending "upward"
then "downward". The y-filter is called by each process with the arguments 
corresponding to the position in the image. 

Passing the filtered image back to the root process is done by the last process 
first sending the filtered left over part from the integer division. The main
part of the image is passed back using the gather function.
The root then writes the image back to a file.
 

\subsection{Performance}
The execution time is measured using the MPI\_Wtime() function. It is started
after the root processor has calculated the Gaussian
coefficients and is ended before the root processor writes the output file.

\subsection{Source}

\section{Threshold Filter}
The threshold filter computes the average intensity of the image and then use
this as a threshold value.

\subsection{Description}
The parallelized code keeps the basic structure of the example code provided on
the course homepage and the parallelization is done in a straight forward
fashion. As in the averaging filter the image is split horizontally, but in this
implementation the root process takes care of the part remaining after the
integer division.

The filter function has been split into two separate functions, one calculating the threshold
value and one doing the filtering.

When starting the execution the root process reads the image followed by a
broadcast of the total size. Each process then allocate memory for its slice of
the image. After the root process has scattered the image, the processes
calculate a threshold value for their local part followed by an all reduce
function to add all local values together to a global threshold.

All processes then runs the filter on their local part, with the root
calculating a slightly larger portion. The gather function is used to pass the
filtered image back to the root process, which writes back to file.

\subsection{Performance}

The execution time is measured using the MPI\_Wtime() function. It is started
after the root processor has read the input file
and is ended before writing the output file.

\subsection{Source}

\end{document}
