\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{fancyhdr}

\pagestyle{fancy}
\lhead{TDDC78 Lab 1}
\rhead{Hallberg, Svensk}

\begin{document}

\title{TDDC78 Lab 1\\
        Image filter - MPI}
\author{Christopher Hallberg \\
        Gustav Svensk}
\maketitle

\thispagestyle{empty}

\newpage
\setcounter{page}{1}
\tableofcontents
\newpage

\section{Averaging Filter}
In the average filter each pixel gets its value according to a weighted average
of neighbouring pixels in the shape of a rectangle with a user specified radius. 
Our implementation uses the given Gaussian distribution.

\subsection{Description}
This section provides a high level overview of the parallel program. 
The code is of the same structure as the one provided on the course homepage,
but with added functionality for MPI. When the
program is started the root processor reads the input file and calls
the function calculating the Gaussian coefficients. The root processor then
broadcasts Gaussian coefficients, radius of the rectangle and size of the image.


In order to utilize the cache functionality as much as possible we split the image
horizontally in equally large parts. If the y-size of the image is not divisible
by the number of processors used the last processor will be assigned the
additional lines. Each processor will allocate local memory for their part of the
image plus extra shadow pixels needed to filter along the y-axis. The memory
needed for these shadow pixels will correspond to two times the width of the
image times the radius of the filtering rectangle. The root processor then 
scatters the image to every processor.  

The filter function provided have been split into two separate functions, the
first filtering along the x-axis and the other filtering along the y-axis. Some
small changes had to be made to copy memory and handle the shadow pixels. The
y-filter have two additional arguments specifying if the process will need
information about shadow pixels from another process or not. 

If there is only one process it will just call the two filter functions. If
there are more than one process the root process first sends the part of the
image left over after the integer division to the last process. All processes
filter along the x-axis which require no message passing between them.
The required shadow pixels are then passed, starting by first sending "upward"
then "downward". The y-filter is called by each process with the arguments 
corresponding to the position in the image. 

Passing the filtered image back to the root process is done by the last process 
first sending the filtered left over part from the integer division. The main
part of the image is passed back using the gather function.
The root then writes the image back to memory.
 

\subsection{Performance}
The execution time is measured using the MPI\_Wtime() function. It is started
after the root processor has calculated the Gaussian
coefficients and is ended before the root processor writes the output file.

\subsection{Source}

\section{Threshold Filter}
\subsection{Description}
\subsection{Performance}
\subsection{Source}

\end{document}
