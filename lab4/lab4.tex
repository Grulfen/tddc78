\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{listings}

\lstset{language=c++,
        basicstyle=\ttfamily\scriptsize,
        numbers=left}

\pagestyle{fancy}
\lhead{TDDC78 Lab 4}
\rhead{Hallberg, Svensk}

\begin{document}

\title{TDDC78 Lab 4\\
        Particle Simulation - MPI}
\author{Christopher Hallberg \\
        Gustav Svensk}
\maketitle

\thispagestyle{empty}

\newpage
\setcounter{page}{1}
\tableofcontents
\newpage

\section{Description}
This section provides a high level overview of the parallel program.
The structure of the program is:
\begin{itemize}
\item Setup
\item Particle generation
\item Simulation
\item Reduction
\end{itemize}
Our implementation is restricted to only run on a square number of processes,
this is to make it easier to split the particles among the processes. In our case
each process takes care of a smaller square and initializes particles inside.

We used vectors to store the particles to be able to benefit from cache effects,
and to avoid memory allocation and deallocation in the critical loop.
Using vectors also makes it easier to communicate the particles between processes.

\subsection{Setup}
In the setup phase the root processor broadcasts the number of time steps and
the number of particles in the simulation to every process. The communication
grid is setup using MPI\_Cart\_create and each process gets the id of its
neighbours via MPI\_Cart\_shift. The ids of the neighbours are saved in an
array. If a process does not have a neighbour the special id MPI\_PROC\_NULL is
saved instead. Each process checks if it has a wall on any of its sides. 
Each process has its own local coordinates.

\subsection{Particle generation}
In this phase each process generates as many particles as indicated by the
command line argument num\_particles. The particles position and velocity is
randomly generated. The function \textit{generate\_particles} is used to generate
the particles.
\subsection{Simulation}
The simulation phase contains a for-loop over the time steps. Inside the loop
each particle is checked for collisions with other particles, wall collisions,
whether the particle should be passed to another process and finally the
particles are communicated between the processes.

The details of the collision detection and handling can be seen in section
\ref{sec:src}.

If a particle is outside of the square it has either collided with a wall or
will pass over to another square. If it has a wall on that side the function
\textit{wall\_collide} is used to calculate the momentum and move the particle.
If there is no wall the particle is moved to a communication buffer and in the
end of the loop all the particles in the communication buffer are sent to the
corresponding neighbour.

When communicating between the processes the neighbour array is used. If a
process uses MPI\_Send to the special id MPI\_PROC\_NULL it immediately returns,
using this the communication can be done with a simple loop without any edge cases
for processes in the corners or edges of the box.

\subsection{Reduction}
In the reduction phase the local momentum calculated in all the processes are
summed in the root process using MPI\_Reduce. The pressure is then calculated
by dividing the momentum by the number of time steps and the wall length of the
box.

\section{Performance}
\section{Source}
\label{sec:src}

\newpage
\appendix
\section{Figures}
\label{sec:fig}

\end{document}
